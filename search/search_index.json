{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Next.js is an open-source web development framework built on top of React, which enables web applications with server-side rendering and generating static websites.</p> <pre><code>npx create-next-app@latest next-hello-world\n</code></pre> <p></p>"},{"location":"index.html#let-me-talk-about-history-of-nextjs1","title":"Let me talk about: History of Next.js1","text":"<p>Next.js was released by Vercel (formerly known as Zeit) in 2016. The framework was developed to address issues with React, which was popular at the time but had problems with accessibility, security, slow page loading times, and SEO.</p> <p>Next.js aimed to solve these issues, and has since gained popularity.</p> <p>In 2019, Google began contributing to the project. Today, many large websites such as Walmart, Apple, Nike, Net ix, TikTok, Uber, Lyft, and Starbucks use the framework.</p> <p>Next.js is often credited with completing React by o ering the following features:</p> <ul> <li>Server-Side Rendering</li> <li>Static Site Generation</li> <li>Image Optimization</li> <li>Built-in Routing</li> </ul> <p>These features have made Next.js a popular choice among developers looking to build powerful and performant web applications.</p>"},{"location":"index.html#reference","title":"Reference","text":"<ul> <li>Dynamic Trio by By Grace Huang, pg: 20</li> </ul>"},{"location":"blog/index.html","title":"Index","text":""},{"location":"blog/index.html#blog","title":"Blog","text":""},{"location":"miscellaneous/intro.html","title":"Intro","text":""},{"location":"miscellaneous/intro.html#intro","title":"Intro","text":"<ul> <li>Merge: Preserves History, Non-linear History</li> <li>Rebase: Rewrites History, Linear History</li> </ul> <pre><code>docs/\n\u251c\u2500\u2500 websockets/\n\u2502   \u251c\u2500\u2500 introduction.md\n\u2502   \u251c\u2500\u2500 setup.md\n\u2502   \u251c\u2500\u2500 examples.md\n\u2502   \u2514\u2500\u2500 troubleshooting.md\n\u2514\u2500\u2500 push-notifications/\n    \u251c\u2500\u2500 introduction.md\n    \u251c\u2500\u2500 setup.md\n    \u251c\u2500\u2500 examples.md\n    \u2514\u2500\u2500 best-practices.md\n\n\nnav:\n  - Home: index.md\n  - WebSockets:\n      - Introduction: websockets/introduction.md\n      - Setup: websockets/setup.md\n      - Examples: websockets/examples.md\n      - Troubleshooting: websockets/troubleshooting.md\n  - Push Notifications:\n      - Introduction: push-notifications/introduction.md\n      - Setup: push-notifications/setup.md\n      - Examples: push-notifications/examples.md\n      - Best Practices: push-notifications/best-practices.md\n</code></pre> <p>uncaught referenceerror can t access lexical declaration before initialization</p> <pre><code>uncaught referenceerror can t access lexical declaration before initialization\n\n// axiosBaseQuery.js\nimport axiosInstance from \"./axiosInstance\";\n\nexport const axiosBaseQuery =\n  ({ baseUrl } = { baseUrl: \"\" }) =&gt;\n  async ({ url, method, meta, data, params, headers }) =&gt; {\n    try {\n      const result = await axiosInstance.base({\n        url: baseUrl + url,\n        method,\n        meta,\n        data,\n        params,\n        headers,\n      });\n\n      return { data: result.data, meta: { ...meta, method } };\n    } catch (axiosError) {\n      const err = axiosError;\n      return {\n        error: {\n          status: err.response?.status,\n          data: err.response?.data || err.message,\n          meta: { ...meta, method },\n        },\n      };\n    }\n  };\n\n// export default axiosBaseQuery;\n\n\n// passwordReset.js\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { axiosBaseQuery } from \"@shared/services/axios/axiosBaseQuery\";\nimport { HTTP_METHODS } from \"@shared/utils/httpMethods\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport logger from \"@shared/utils/logger\";\n\nexport const passwordApi = createApi({\n  reducerPath: \"passwordApi\",\n  baseQuery: axiosBaseQuery({\n    baseUrl: CONFIG.API_BASE_URL,\n  }),\n  endpoints: (builder) =&gt; ({\n    postPasswordReset: builder.mutation({\n      query: ({ id, data }) =&gt; ({\n        url: `Users/password-reset/${id}`,\n        method: HTTP_METHODS.POST,\n        data,\n      }),\n    }),\n  }),\n});\n\nexport const { usePostPasswordResetMutation } = passwordApi;\n\n\n// axiosInstace.js\n\nimport axios from \"axios\";\nimport { store } from \"@shared/store/store\";\nimport axiosConfig from \"./axiosConfig\";\n\nconst axiosInstance = {\n  base: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n    ...axiosConfig,\n  }),\n  login: axios.create({\n    baseURL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n    ...axiosConfig,\n  }),\n};\n\naxiosInstance.base.interceptors.request.use(\n  (config) =&gt; {\n    const state = store.getState();\n    const token = state.auth.token;\n\n    if (token) {\n      config.headers[\"Authorization\"] = `Bearer ${token}`;\n    }\n    return config;\n  },\n  (error) =&gt; {\n    return Promise.reject(error);\n  }\n);\n\nexport default axiosInstance;\n\n\n// config.js\nexport const CONFIG = {\n  BASE_URL: import.meta.env.VITE_REACT_APP_LOGIN_API_URL,\n  API_BASE_URL: import.meta.env.VITE_REACT_APP_BASE_API_URL,\n  LOGIN_URL: import.meta.env.VITE_REACT_APP_DUMMY_API_URL,\n  LOG_LEVEL: import.meta.env.VITE_REACT_APP_LOG_LEVEL,\n  MODE: import.meta.env.MODE,\n};\n\nexport const OAUTH = {\n  CLIENT_ID: import.meta.env.VITE_REACT_APP_CLIENT_ID,\n  CLIENT_SECRET: import.meta.env.VITE_REACT_APP_CLIENT_SECRET,\n  SCOPE: import.meta.env.VITE_REACT_APP_SCOPE,\n  GRANT_TYPE: import.meta.env.VITE_REACT_APP_GRANT_TYPE,\n};\n</code></pre> <p>The error message <code>Uncaught ReferenceError: Can't access lexical declaration before initialization</code> typically occurs when a variable declared using let, const, or class is accessed before its initialization in the code. This is a result of the temporal dead zone (TDZ) behavior in JavaScript, where variables declared with <code>let</code> or <code>const</code> are hoisted but not initialized until their declaration is evaluated at runtime.</p> The Root Cause <p>In your case, this error is likely happening because of how the imports and the execution flow are handled in the file.</p> <p>Here's the flow of what might be happening:</p> <ol> <li><code>axiosBaseQuery.js</code> exports <code>axiosBaseQuery</code> (an asynchronous function).</li> <li><code>passwordReset.js</code> imports <code>axiosBaseQuery</code> and uses it in the createApi function from Redux Toolkit.</li> </ol> <p>The error occurs when <code>axiosBaseQuery</code> is being imported and used before it is fully initialized.</p> Why it Happens <p>It seems the problem arises due to how you're using <code>axiosBaseQuery</code> in the <code>baseQuery</code> property. Since <code>axiosBaseQuery</code> is a function that uses <code>async/await</code>, it might be referencing some state or other imports that could be running before the module is fully initialized. The error might be appearing because you are trying to use something (likely part of the <code>baseUrl</code> or the configuration) before it\u2019s ready.</p> Possible Solutions <ol> <li> <p>Rearrange imports in <code>passwordReset.js</code>:</p> <p>Try reordering the imports in <code>passwordReset.js</code> to ensure that the <code>axiosBaseQuery</code> is fully initialized before it\u2019s used:</p> <pre><code>import { axiosBaseQuery } from \"@shared/services/axios/axiosBaseQuery\";\nimport { createApi } from \"@reduxjs/toolkit/query/react\";\nimport { HTTP_METHODS } from \"@shared/utils/httpMethods\";\nimport { CONFIG } from \"@shared/utils/config\";\nimport logger from \"@shared/utils/logger\";\n</code></pre> </li> </ol> <ul> <li>ReferenceError: can't access lexical declaration`X' before initialization</li> <li>ReferenceError: can't access lexical declaration before initialization when using createAsyncThunk with createReducer #687</li> <li> <p>ReferenceError: can't access lexical declaration 'X' before initialization</p> </li> <li> <p>Using Axios Instance with Interceptors in Redux Toolkit Query (RTK Query)</p> </li> </ul> when to use () and when to use {}<pre><code>const api = createApi({\n  baseQuery: axiosBaseQuery({\n    baseUrl: \"https://example.com\",\n  }),\n  endpoints(build) {\n    return {\n      query: build.query({ query: () =&gt; ({ url: \"/query\", method: \"get\" }) }),\n      mutation: build.mutation({\n        query: () =&gt; ({ url: \"/mutation\", method: \"post\" }),\n      }),\n    };\n  },\n});\n</code></pre> <ul> <li>GIST: Axios Base Query for RTK Query (redux toolkit)</li> </ul> <p>Warning: Instance created by <code>useForm</code> is not connected to any Form element. Forget to pass <code>form</code> prop?</p> <ul> <li>Github: Incorrect console warning on useForm is not connected to Form eleme</li> </ul>"},{"location":"miscellaneous/intro.html#memo","title":"memo","text":"<p><code>React.memo</code> is a higher-order component (HOC) that memoizes the component, which prevents unnecessary re-renders. I</p> <p><code>React.memo</code> performs a shallow comparison of the props passed to the component. This means that if any prop is a complex object (e.g., an array or an object) and it changes reference, <code>React.memo</code> will trigger a re-render even if the object's contents haven't changed.</p>"},{"location":"miscellaneous/intro.html#antd-form-submit-button-outside-form","title":"Antd Form Submit Button Outside Form","text":"<p>The issue you're encountering is that the \"Submit\" button doesn't trigger the <code>handleReset</code> function, even though the form's <code>onFinish</code> event is tied to it. This is likely because the button's <code>htmlType=\"submit\"</code> doesn't properly trigger the form submission, possibly due to how the button is being handled or the form's validation requirements.</p> <p>To ensure the <code>handleReset</code> function is properly called when the \"Submit\" button is clicked, here's what you can check and fix:</p> <ol> <li> <p>Ensure the Button is Inside the Form</p> <p>Make sure that the <code>Submit</code> button is within the <code>Form</code> component. This is necessary for the <code>htmlType=\"submit\"</code> to work properly, as it tells the form to trigger the onFinish event.</p> </li> <li> <p>Add <code>onFinishFailed</code> if Needed</p> <p>If the form has validation rules, you might want to handle cases where validation fails. However, this isn't necessary unless you have validation rules in place.</p> </li> <li> <p>Fix Button Outside of Form: If you still want the button to trigger the form submission but keep it outside of the <code>Form</code> component, you can use the <code>form.submit()</code> method programmatically.</p> </li> </ol> CodeExplanation <pre><code>import React, { useId } from \"react\";\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleReset = (values) =&gt; {\n        // Log the form values\n        logger.info({ msg: \"RESET\", values });\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                &lt;Button\n                    type=\"primary\"\n                    onClick={() =&gt; form.submit()} // Trigger the form submission programmatically\n                &gt;\n                    Submit\n                &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        message: \"Please enter your new password\",\n                        },\n                    ]}\n                &gt;\n                    &lt;Input.Password\n                        placeholder=\"Enter new password\"\n                        autoComplete=\"new-password\"\n                    /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <p>Explanation of Changes:</p> <ol> <li> <p><code>form.submit()</code>:</p> <p>The <code>onClick</code> of the \"Submit\" button now calls <code>form.submit()</code>. This will trigger the form's <code>onFinish</code> event manually, even if the button is outside the form. This ensures that the form will submit and call the <code>handleReset</code> function.</p> </li> <li> <p>Validation Rule for Password:</p> <p>I added a simple validation rule (<code>required: true</code>) to the <code>Form.Item</code> to ensure the form won't submit without a password. This can be customized according to your requirements.</p> </li> <li> <p><code>onFinish</code> Handling:</p> <p>The <code>handleReset</code> function will receive the form values when it's triggered. You can then log or process them.</p> </li> </ol> <p>How It Works:</p> <ul> <li>When you click the \"Submit\" button, it calls <code>form.submit()</code>, which submits the form and triggers the <code>onFinish</code> event.</li> <li>The <code>handleReset</code> function is triggered, and the form values are logged.</li> </ul> success <pre><code>// Internal\nimport React, { useId, useState } from \"react\";\n// Theme\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\n// Shared\nimport { validatePassword } from \"@shared/utils/validatePassword\";\nimport { usePostPasswordResetMutation } from \"@features/settings/services/passwordApi\";\n// Log\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n    const [isLoadingButton, setIsLoadingButton] = useState(false);\n\n    const [postPasswordReset, { isLoading, isError, error }] =\n        usePostPasswordResetMutation();\n\n    const handleReset = async (values) =&gt; {\n        setIsLoadingButton(true);\n        try {\n            logger.info({ msg: \"RESET\", values, id });\n            await postPasswordReset({ id, data: values }).unwrap();\n            form.resetFields();\n            onClose();\n        } catch (error) {\n            logger.error({ msg: \"RESET Password\", error });\n        } finally {\n            setIsLoadingButton(false);\n        }\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                    &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                    &lt;Button\n                        type=\"primary\"\n                        onClick={() =&gt; {\n                            form\n                                .validateFields()\n                                .then((values) =&gt; {\n                                handleReset(values);\n                                })\n                                .catch((errorInfo) =&gt; {\n                                logger.error({ msg: \"Error\", errorInfo });\n                                });\n                        }}\n                        htmlType=\"submit\"\n                    &gt;\n                        Submit\n                    &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"newPassword\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        // message: \"Please enter password\",\n                        },\n                        { validator: validatePassword },\n                    ]}\n                    hasFeedback\n                &gt;\n                &lt;Input.Password\n                    placeholder=\"Enter new password\"\n                    autoComplete=\"new-password\"\n                /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <p>Modified Code</p> <p>To ensure the form is submitted only when the validatePassword function passes (i.e., the password validation succeeds), you need to modify the logic in the PasswordReset component, specifically the part where you trigger the form submission.</p> StepsCODEKey Changes: <p>Here\u2019s how you can modify the PasswordReset component:</p> <p>Key Steps:</p> <ol> <li>Ensure that <code>validatePassword</code> runs before submitting the form.</li> <li>Only submit the form when <code>validatePassword</code> passes.</li> </ol> <p>Modifications to your existing code:</p> <ul> <li>You need to modify the logic where you check for form submission (<code>onClick</code> handler for the submit button).</li> <li>Since <code>validatePassword</code> already handles the validation within the <code>Form.Item</code>, the form will automatically stop submission if the validation fails.</li> <li>If you want to explicitly control the validation, you can use the <code>form.validateFields()</code> method to trigger validation manually.</li> </ul> <pre><code>import React, { useId } from \"react\";\nimport { Drawer, Button, Space, Form, Input } from \"antd\";\nimport { validatePassword } from \"@shared/utils/validatePassword\";\nimport logger from \"@shared/utils/logger\";\n\nconst PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {\n    const [form] = Form.useForm();\n\n    const handleReset = (values) =&gt; {\n        logger.info({ msg: \"RESET\", values });\n    };\n\n    const handleSubmit = () =&gt; {\n        // Manually trigger validation before form submission\n        form\n            .validateFields() // This triggers validation for all fields\n            .then((values) =&gt; {\n                // If validation is successful, call handleReset\n                handleReset(values);\n            })\n            .catch((errorInfo) =&gt; {\n                // Handle validation failure (if necessary)\n                console.log(\"Validation failed:\", errorInfo);\n            });\n    };\n\n    return (\n        &lt;Drawer\n            title=\"Reset Password\"\n            open={visible}\n            onClose={() =&gt; {\n                onClose();\n                form.resetFields();\n            }}\n            closable={false}\n            footer={\n                &lt;Space&gt;\n                    &lt;Button onClick={onClose}&gt;Cancel&lt;/Button&gt;\n                    &lt;Button\n                        type=\"primary\"\n                        onClick={handleSubmit} // Use handleSubmit instead of directly submitting\n                        htmlType=\"submit\"\n                    &gt;\n                        Submit\n                    &lt;/Button&gt;\n                &lt;/Space&gt;\n            }\n        &gt;\n            &lt;Form form={form} layout=\"vertical\" onFinish={handleReset}&gt;\n                &lt;Form.Item\n                    name=\"password\"\n                    label=\"Password\"\n                    rules={[\n                        {\n                        required: true,\n                        // message: \"Please enter password\",\n                        },\n                        { validator: validatePassword },\n                    ]}\n                    hasFeedback\n                &gt;\n                    &lt;Input.Password\n                        placeholder=\"Enter new password\"\n                        autoComplete=\"new-password\"\n                    /&gt;\n                &lt;/Form.Item&gt;\n            &lt;/Form&gt;\n        &lt;/Drawer&gt;\n    );\n});\n\nexport default PasswordReset;\n</code></pre> <ol> <li> <p><code>handleSubmit</code> method: This is where we explicitly call <code>form.validateFields()</code>. If the validation passes (i.e., the password matches the validation criteria), it will proceed to call <code>handleReset</code>. If validation fails, it will not submit the form.</p> </li> <li> <p>Form submission: Instead of directly calling <code>form.submit()</code> in the button's <code>onClick</code>, we call the <code>handleSubmit</code> method, which handles both validation and submission.</p> </li> </ol> <p>This setup ensures that the form will only submit if the password passes all validation criteria specified in <code>validatePassword</code>.</p>"},{"location":"miscellaneous/intro.html#bug","title":"Bug","text":"<p>Warning: React does not recognize the <code>hasFeedback</code> prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase <code>hasfeedback</code> instead. If you accidentally passed it from a parent component, remove it from the DOM element. Component Stack: </p> <ul> <li>Official React: memo</li> <li>W3Schools: React Memo</li> </ul>"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html","title":"Hooks vs HoC","text":""},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#hooks-vs-hocs-which-is-better","title":"\u2705 Hooks vs HOCs: Which is Better?","text":"<p>You're right! Hooks are often better and more modern than HOCs for handling shared logic in React. However, both patterns have their place. Let me clarify:</p>"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#hocs-vs-hooks-key-differences","title":"\ud83c\udd9a HOCs vs Hooks: Key Differences","text":"Aspect Higher-Order Components (HOCs) Hooks Introduced in React 16.0 React 16.8 Code Reusability Wrap components to add functionality Reuse logic directly in functional components Complexity Can lead to wrapper hell (nested HOCs) Simpler and cleaner code Performance Slightly slower due to component wrapping Faster and more direct UI Manipulation Harder to manipulate UI inside HOCs Easier to control UI with hooks Stateful Logic Harder to manage complex state logic Hooks handle complex state elegantly Modern Approach Older pattern Recommended for new projects"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#example-data-fetching","title":"\ud83e\uddea Example: Data Fetching","text":"\ud83c\udfd7\ufe0f Using HOC for Data Fetching<pre><code>const withDataFetching = (WrappedComponent, url) =&gt; {\n  return (props) =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() =&gt; {\n      fetch(url)\n        .then((response) =&gt; response.json())\n        .then((data) =&gt; {\n          setData(data);\n          setLoading(false);\n        });\n    }, [url]);\n\n    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n    return &lt;WrappedComponent {...props} data={data} /&gt;;\n  };\n};\n\nconst UserList = ({ data }) =&gt; (\n  &lt;ul&gt;\n    {data.map((user) =&gt; (\n      &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n\nexport default withDataFetching(\n  UserList,\n  \"https://jsonplaceholder.typicode.com/users\"\n);\n</code></pre> \ud83d\ude80 Using Hooks for Data Fetching (Better Way)<pre><code>import { useState, useEffect } from \"react\";\n\nconst useFetchData = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading };\n};\n\nconst UserList = () =&gt; {\n  const { data, loading } = useFetchData(\n    \"https://jsonplaceholder.typicode.com/users\"\n  );\n\n  if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default UserList;\n</code></pre>"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#why-hooks-are-better-in-modern-react","title":"\ud83d\udd11 Why Hooks Are Better in Modern React:","text":"<ol> <li> <p>Cleaner Code:</p> <p>No need to create a separate wrapper component.</p> </li> <li> <p>Avoid Wrapper Hell:</p> <p>HOCs can cause nested components (wrapper hell), making your component tree harder to understand and debug.</p> </li> <li> <p>Flexible and Composable:</p> <p>Hooks are more flexible and easier to compose compared to HOCs. You can combine multiple hooks within a single component.</p> </li> <li> <p>Direct Access to State and Lifecycle:</p> <p>Hooks give direct access to state and lifecycle methods, making it easier to manage complex logic.</p> </li> </ol>"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#when-should-you-use-hocs","title":"\ud83d\udcda When Should You Use HOCs?","text":"<p>Despite hooks being better, there are some cases where HOCs are still useful:</p> <ul> <li>\u2705 Access Control (Authorization HOCs)</li> <li>\u2705 Adding Global Logic (Logging, Error Boundaries)</li> <li>\u2705 Theming HOCs</li> <li>\u2705 Codebases that haven\u2019t migrated to hooks yet</li> </ul>"},{"location":"miscellaneous/hoc/hooks-vs-hocs.html#conclusion","title":"\ud83d\udca1 Conclusion:","text":"<ul> <li>\ud83d\udc49 Use Hooks for most cases.</li> <li>\ud83d\udc49 Use HOCs only if you're dealing with access control, theming, or legacy codebases that already rely on HOCs.</li> </ul>"},{"location":"miscellaneous/hoc/hooks.html","title":"Hooks Reference","text":""},{"location":"miscellaneous/hoc/hooks.html#hooks-to-fuel-your-web-applications","title":"Hooks to fuel your web applications","text":"<p>Hooks are a special kind of creature in the React biosphere. From the outside, they seem completely unrelated in functionality, but when examined closer, they have some common traits and behaviors that we need to account for when using them. You could say that they stem from a common ancestor somewhere in the evolutionary tree, even though they have advanced to become very different beings.</p> <p>You've seen three different hooks up until now: useState (in chapter 5) plus <code>useEffect</code> and <code>useLayoutEffect</code> (in chapter 6). There are at this time 15 built-in hooks in React (as of <code>React 18</code>) and we're going to briefly cover all of them grouped by their functionality.</p> <ul> <li> <p>The stateful hooks. These are functions that are concerned with making components and applications stateful on several different layers and levels of complexity: <code>useState</code>, <code>useReducer</code>, <code>useRef</code>, <code>useContext</code>, <code>useDeferredValue</code>, and <code>useTransition</code>.</p> </li> <li> <p>The effect hooks. These are functions that are concerned with running effects inside a component at different stages of the overall component lifecycle as well as during each individual render cycle: <code>useEffect</code> and <code>useLayoutEffect</code>.</p> </li> <li> <p>The memoization hooks. These are functions that are used for performance optimization via avoiding re-calculating values, if their constituent parts haven't changed: <code>useMemo</code>, <code>useCallback</code>, <code>useId</code>.</p> </li> <li> <p>The library hooks. These are advanced functions almost exclusively used in larger component libraries that are created to be shared either with the community or internally in a larger organization. These functions are rarely used in smaller or medium-size applications: <code>useDebugValue</code>, <code>useImperativeHandle</code>, <code>useInsertionEffect</code>, and <code>useSyncExternalStore</code>.</p> </li> </ul> <p>These 15 hooks are the built-in \"base\" hooks that React comes with. You can build more hooks on top of that, but you cannot build your own \"base\" hooks.</p> <p>You can only build hooks that utilize one or more of the existing hooks. We will be discussing custom hooks in future chapters a couple of times. Do note that React might be extended with more built-in hooks in future releases. <code>React 18.0</code> came with 5 new hooks, and incremental releases after React 18 might come with even more.</p> React New Hooks <ul> <li>useId</li> <li>useDeferredValue</li> <li>useTransition</li> <li>useSyncExternalStore</li> <li>useInsertionEffect</li> </ul>"},{"location":"miscellaneous/hoc/hooks.html#reference","title":"Reference","text":"<ul> <li>Book: React Quickly, Second Edition MEAP V1 by Morten Barklund and Azat Mardan, pg: 288</li> <li>Example: New Hooks in React 18, geeksforgeeks.org</li> <li>Example: Using New Hooks in Rect 18</li> <li>Oficial Site: Hooks by Category, legacy</li> <li>Oficial Site: Functional Update, legacy</li> </ul>"},{"location":"miscellaneous/hoc/intro.html","title":"Intro","text":""},{"location":"miscellaneous/hoc/intro.html#what-is-a-higher-order-component-hoc-in-react","title":"\ud83d\udcda What is a Higher-Order Component (HOC) in React?","text":"<p>A Higher-Order Component (HOC) is a function that takes a component as an argument and returns a new component. It allows you to reuse component logic by wrapping one or more components in a new component with additional functionality.</p> <p>HOCs follow the principle of \"don't repeat yourself\" (DRY) by abstracting shared logic that can be reused across multiple components.</p>"},{"location":"miscellaneous/hoc/intro.html#when-to-use-a-higher-order-component-hoc","title":"\u2699\ufe0f When to Use a Higher-Order Component (HOC)","text":"<p>Here are some common scenarios where you can use HOCs:</p> <ol> <li> <p>Access Control (Authorization)</p> <p>To protect routes or restrict access to certain components based on user roles or authentication status.</p> </li> <li> <p>Data Fetching / API Integration</p> <p>Wrap components to handle data fetching logic and pass the data as props.</p> </li> <li> <p>Conditional Rendering</p> <p>Dynamically show or hide components based on certain conditions.</p> </li> <li> <p>Logging and Analytics</p> <p>Track user interactions with specific components.</p> </li> <li> <p>Theming / Styling</p> <p>Apply consistent styles or themes to multiple components.</p> </li> <li> <p>Performance Optimization</p> <p>Use memoization or lazy loading to optimize the performance of wrapped components.</p> </li> </ol>"},{"location":"miscellaneous/hoc/intro.html#syntax-of-a-higher-order-component-in-react","title":"\ud83d\udcc4 Syntax of a Higher-Order Component in React","text":"\u2705 Basic HOC Syntax:<pre><code>import React from \"react\";\n\n// Higher-Order Component\nconst withExtraProps = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    // Add new props or modify existing props\n    const extraProps = { additionalData: \"Hello from HOC\" };\n\n    // Return the wrapped component with new props\n    return &lt;WrappedComponent {...props} {...extraProps} /&gt;;\n  };\n};\n\n// Component to be wrapped\nconst MyComponent = (props) =&gt; {\n  return &lt;div&gt;{props.additionalData}&lt;/div&gt;;\n};\n\n// Using the HOC\nconst EnhancedComponent = withExtraProps(MyComponent);\n\nexport default EnhancedComponent;\n</code></pre>"},{"location":"miscellaneous/hoc/intro.html#example-use-cases-of-hocs","title":"\ud83d\udcc2 Example Use Cases of HOCs","text":"\u2705 1. Authorization HOC (Access Control):<pre><code>const withAuthorization = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    const isAuthenticated = localStorage.getItem(\"token\");\n\n    if (!isAuthenticated) {\n      return &lt;h1&gt;Access Denied. Please log in.&lt;/h1&gt;;\n    }\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n};\n\nconst Dashboard = (props) =&gt; {\n  return &lt;h1&gt;Welcome to your Dashboard!&lt;/h1&gt;;\n};\n\nconst ProtectedDashboard = withAuthorization(Dashboard);\nexport default ProtectedDashboard;\n</code></pre> \u2705 2. Data Fetching HOC:<pre><code>import React, { useEffect, useState } from \"react\";\nimport axios from \"axios\";\n\nconst withDataFetching = (WrappedComponent, url) =&gt; {\n  return (props) =&gt; {\n    const [data, setData] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() =&gt; {\n      axios.get(url).then((response) =&gt; {\n        setData(response.data);\n        setLoading(false);\n      });\n    }, [url]);\n\n    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;\n\n    return &lt;WrappedComponent {...props} data={data} /&gt;;\n  };\n};\n\nconst UserList = ({ data }) =&gt; {\n  return (\n    &lt;ul&gt;\n      {data.map((user) =&gt; (\n        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  );\n};\n\nexport default withDataFetching(\n  UserList,\n  \"https://jsonplaceholder.typicode.com/users\"\n);\n</code></pre> \u2705 3. Logging HOC:<pre><code>const withLogging = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    useEffect(() =&gt; {\n      console.log(\"Component Mounted:\", WrappedComponent.name);\n    }, []);\n\n    return &lt;WrappedComponent {...props} /&gt;;\n  };\n};\n\nconst Button = (props) =&gt; {\n  return &lt;button&gt;{props.label}&lt;/button&gt;;\n};\n\nexport default withLogging(Button);\n</code></pre>"},{"location":"miscellaneous/hoc/intro.html#key-points-to-remember-about-hocs","title":"\ud83d\udee0\ufe0f Key Points to Remember about HOCs:","text":"<ol> <li> <p>Pure Functions:</p> <p>HOCs are pure functions, meaning they don't modify the original component.</p> </li> <li> <p>Props Passing:</p> <p>Always pass the original props to the wrapped component to ensure no data is lost.</p> <pre><code>return &lt;WrappedComponent {...props} /&gt;;\n</code></pre> </li> <li> <p>Naming Convention:</p> <p>It\u2019s a convention to prefix the HOC function with \"with\" (e.g., <code>withAuthorization</code>, <code>withLogging</code>).</p> </li> <li> <p>Don't Use HOCs Inside the Render Method:</p> <p>Never create HOCs inside a component's render method. It can cause performance issues.</p> </li> </ol>"},{"location":"miscellaneous/hoc/intro.html#when-to-use-hocs-vs-other-patterns-hooks-render-props","title":"\ud83e\udd14 When to Use HOCs vs Other Patterns (Hooks, Render Props)?","text":"Scenario Use HOC Use Hooks Reusing logic across components \u2705 \u2705 Access control (Auth) \u2705 \u2705 Data fetching \u2705 \u2705 UI state management \u274c Use Context or Hooks \u2705 Performance optimization \u2705 \u2705"},{"location":"miscellaneous/hoc/naming-convention.html","title":"Naming Convention","text":""},{"location":"miscellaneous/hoc/naming-convention.html#naming-conventions-for-hocs-and-hooks-in-react","title":"\u2705 Naming Conventions for HOCs and Hooks in React","text":"<p>When working with HOCs and custom hooks, it's important to follow consistent naming conventions to improve code readability and maintainability.</p>"},{"location":"miscellaneous/hoc/naming-convention.html#naming-conventions-for-higher-order-components-hocs","title":"\ud83d\udcc4 Naming Conventions for Higher-Order Components (HOCs)","text":"<p>\u2705 Filename:</p> <ul> <li>Start the filename <code>with</code> with to indicate it's a HOC.</li> </ul> <p>\u2705 Example:</p> Component Purpose Filename Authorization HOC <code>withAuthorization.js</code> Logging HOC <code>withLogging.js</code> Data Fetching HOC <code>withDataFetching.js</code> <p>\u2705 Function Name:</p> <ul> <li>Use the same name as the file for consistency.</li> </ul> <pre><code>// File: withAuthorization.js\nconst withAuthorization = (WrappedComponent) =&gt; {\n  return (props) =&gt; {\n    const isAuthenticated = localStorage.getItem(\"token\");\n    return isAuthenticated ? (\n      &lt;WrappedComponent {...props} /&gt;\n    ) : (\n      &lt;h1&gt;Access Denied&lt;/h1&gt;\n    );\n  };\n};\n\nexport default withAuthorization;\n</code></pre>"},{"location":"miscellaneous/hoc/naming-convention.html#naming-conventions-for-custom-hooks","title":"\ud83d\udcc4 Naming Conventions for Custom Hooks","text":"<p>\u2705 Filename:</p> <ul> <li>Start the filename with <code>use</code> to indicate it's a hook.</li> </ul> <p>\u2705 Example:</p> Hook Purpose Filename Data Fetching Hook <code>useFetchData.js</code> Authentication Hook <code>useAuth.js</code> Debounce Hook <code>useDebounce.js</code> <p>\u2705 Function Name:</p> <ul> <li>Use the same name as the file for consistency.</li> </ul> <pre><code>// File: useFetchData.js\nimport { useState, useEffect } from \"react\";\n\nconst useFetchData = (url) =&gt; {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() =&gt; {\n    fetch(url)\n      .then((response) =&gt; response.json())\n      .then((data) =&gt; {\n        setData(data);\n        setLoading(false);\n      });\n  }, [url]);\n\n  return { data, loading };\n};\n\nexport default useFetchData;\n</code></pre>"},{"location":"miscellaneous/hoc/naming-convention.html#quick-summary-of-naming","title":"\ud83d\udcdd Quick Summary of Naming:","text":""},{"location":"miscellaneous/hoc/naming-convention.html#pro-tip","title":"\ud83d\udd25 Pro Tip:","text":"<p>Keep your HOCs inside a <code>hoc</code> folder and your hooks inside a <code>hooks</code> folder for better structure.</p> <pre><code>\ud83d\udcc2 src\n \u2523 \ud83d\udcc2 hoc\n \u2503 \u2523 \ud83d\udcc4 withAuthorization.js\n \u2503 \u2523 \ud83d\udcc4 withLogging.js\n \u2517 \ud83d\udcc2 hooks\n   \u2523 \ud83d\udcc4 useFetchData.js\n   \u2523 \ud83d\udcc4 useAuth.js\n</code></pre>"},{"location":"miscellaneous/push-notifications/best-practices.html","title":"Best Practices","text":"<p>d</p>"},{"location":"miscellaneous/push-notifications/examples.html","title":"Example","text":"<p>s</p>"},{"location":"miscellaneous/push-notifications/introduction.html","title":"Introduction","text":"<p>Intro</p>"},{"location":"miscellaneous/push-notifications/introduction.html#reference","title":"Reference","text":"<ul> <li>Medium: Real-Time Notifications in React: Types and Implementations</li> <li>Stackoverflow: Websockets vs. iOS Push Notifications</li> <li>Forum: WebSockets vs Push Notifications (AWS Pinpoint)</li> <li>Reddit: SSE or Websockets for push notifications? </li> </ul>"},{"location":"miscellaneous/push-notifications/setup.html","title":"Setup","text":"<p>s</p>"},{"location":"miscellaneous/websockets/examples.html","title":"Example","text":"<ul> <li>SignalR: Best for real-time communication (two-way communication) between clients and server.</li> <li>Push Notifications: Best for one-way alerts to users even when they are not actively interacting with the app.</li> </ul> <p>SignalR Example: A real-time chat app where users can send and receive messages instantly without refreshing the page. You might want to use SignalR to broadcast messages as they come in.</p> <p>Push Notifications Example: A notification when a user receives a new email, even if they are not actively on the app or the browser. This requires setting up push notifications with service workers.</p> <p>No, @microsoft/signalr and push notifications are not the same in React, though both can be used to achieve real-time communication.</p>"},{"location":"miscellaneous/websockets/introduction.html","title":"Introduction","text":"<p>Introduction</p> <p></p>"},{"location":"miscellaneous/websockets/introduction.html#reference","title":"Reference","text":"<ul> <li>Stackoverflow: React JS socket.io-client opens multiple connections</li> <li>Blog: Real-time notifications with React and Socket-IO</li> <li>Blog: The complete guide to WebSockets with React</li> <li>Blog: How to Integrate Socket.IO in ReactJS \u2013 Quick Guide for Beginners</li> <li>Blog: How to Integrate WebSockets into React Apps?</li> <li>Blog: Unlocking how Socket.io can boost your React app's real-time capabilities </li> <li>Blog: Create a Secure Chat Application with Socket.IO and React</li> <li>Blog: Push Notifications and Web Sockets in React Native </li> <li>Image: The Basics of WebSockets</li> <li>Package: @microsoft/signalr</li> </ul>"},{"location":"miscellaneous/websockets/setup.html","title":"Setup","text":"<p>s</p>"},{"location":"miscellaneous/websockets/troubleshooting.html","title":"Troubleshooting","text":""},{"location":"miscellaneous/websockets/troubleshooting.html#react-memo","title":"React Memo","text":"<ol> <li> <p>Usage of <code>React.memo</code>:</p> <p>You are correctly using <code>React.memo</code> around the PasswordReset component:</p> <pre><code>const PasswordReset = React.memo(({ form, id, visible, onClose }) =&gt; { ... });\n</code></pre> <p><code>React.memo</code> is a higher-order component (HOC) that memoizes the component, which prevents unnecessary re-renders. It ensures that <code>PasswordReset</code> only re-renders if its props (<code>form</code>, <code>id</code>, <code>visible</code>, <code>onClose</code>) change.</p> Correct Usage: <ul> <li><code>form</code>, <code>id</code>, <code>visible</code>, and <code>onClose</code> are all props being passed to <code>PasswordReset</code>.</li> <li>If these props don't change, <code>React.memo</code> will prevent re-renders and optimize performance by skipping them.</li> </ul> </li> <li> <p>Understanding When React.memo Works:</p> <p><code>React.memo</code> performs a shallow comparison of the props passed to the component. This means that if any prop is a complex object (e.g., an array or an object) and it changes reference, <code>React.memo</code> will trigger a re-render even if the object's contents haven't changed.</p> In your case: <ul> <li><code>form</code>: If the form object is passed down and is a complex object (e.g., an <code>antd</code> form instance), it might change on every render, causing unnecessary re-renders even with <code>React.memo</code>. If you notice unnecessary re-renders in such cases, consider memoizing or stabilizing the form instance itself.</li> <li><code>id</code>, <code>visible</code>, and <code>onClose</code>: These are simple values (strings, booleans, or functions), so <code>React.memo</code> will work efficiently here as long as the values don\u2019t change on each render.</li> </ul> </li> </ol> Things to Keep in Mind <ol> <li> <p>Memoization:</p> <ul> <li>Ensure that the props passed to the memoized component (<code>form</code>, <code>id</code>, etc.) don\u2019t change unnecessarily. For example, if form is re-created on every render of the parent component (<code>Users.jsx</code>), <code>React.memo</code> won\u2019t prevent a re-render because it will always see a new reference for form.</li> <li>If you're using the <code>antd</code> <code>Form</code> component, keep in mind that instances of forms tend to change references frequently, which can cause re-renders despite <code>React.memo</code>. If that's the case, you may need to consider memoizing or using a stable reference for the form instance.</li> </ul> </li> <li> <p>Functional Updates:</p> <ul> <li>If you're passing functions like <code>onClose</code> and <code>handleClosePasswordDrawer</code> as props, make sure they aren't re-created on each render of the parent (<code>Users.jsx</code>). If these functions are defined inline (e.g., inside the parent component), it could cause re-renders as <code>React.memo</code> will see a new function reference each time.</li> </ul> </li> </ol> <p>You could define the functions outside the render method or use <code>useCallback</code> to prevent unnecessary recreation.</p> <p>Conclusion:</p> <p>Your usage of <code>React.memo</code> is correct in general, but here are some recommendations:</p> <ul> <li>Make sure the props passed to the memoized component don't change frequently (especially complex objects like <code>form</code>).</li> <li>For side effects (like logging), use <code>useEffect</code> to handle them efficiently.</li> <li>Consider using <code>useCallback</code> or <code>useMemo</code> in the parent component to avoid unnecessary re-creations of <code>functions</code> and <code>objects</code> passed as props.</li> </ul>"},{"location":"miscellaneous/websockets/troubleshooting.html#memo","title":"Memo","text":"<p>what are the differents ways to use <code>React.memo</code>;</p> <ol> <li><code>const PasswordReset = React.memo(({ id, visible, onClose }) =&gt; {});</code></li> <li><code>export default memo(Todos);</code></li> </ol>"},{"location":"miscellaneous/websockets/troubleshooting.html#reference","title":"Reference","text":"<ul> <li>Blog: Understanding useMemo and useCallback</li> <li>Blog: What is React memo and how to use it?</li> <li>Blog: React useMemo Hook Guide with Examples</li> <li>Blog: Optimize React Render using useMemo, useCallback, and React.memo</li> <li>How to Work with useMemo in React \u2013 with Code Examples</li> </ul>"},{"location":"nextjs/api-routes.html","title":"API Routes","text":""},{"location":"nextjs/api-routes.html#4-api-routesmd-api-routes-in-nextjs","title":"\ud83d\udcdd 4. <code>api-routes.md</code> (API Routes in Next.js)","text":""},{"location":"nextjs/api-routes.html#api-routes-in-nextjs","title":"\ud83d\udee0 API Routes in Next.js","text":"<p>Next.js allows you to create serverless API routes using file-based routing.</p>"},{"location":"nextjs/api-routes.html#api-routes-in-app-router","title":"\ud83d\udcc2 API Routes in App Router","text":"<p>In the App Router, API routes are defined inside the <code>app/api/</code> folder.</p> <p>Example:</p> <pre><code>app/api/\n\u251c\u2500\u2500 hello/\n\u2502   \u2514\u2500\u2500 route.ts    # API Route: /api/hello\npages/api/\n\u251c\u2500\u2500 hello.js        # API Route: /api/hello\n</code></pre> <pre><code>---\n\n## In the Pages Router, API routes are defined inside the pages/api/ folder.\n\n```\npages/api/\n\u251c\u2500\u2500 hello.js        # API Route: /api/hello\n```\n\n**\ud83d\udccb Example API Route (Pages Router)**\n\n```js\n// pages/api/hello.js\nexport default function handler(req, res) {\n  res.status(200).json({ message: \"Hello, Next.js!\" });\n}\n```\n</code></pre>"},{"location":"nextjs/data-fetching.html","title":"Data Fetching","text":""},{"location":"nextjs/data-fetching.html#5-data-fetchingmd-data-fetching-in-nextjs","title":"\ud83d\udcdd 5. <code>data-fetching.md</code> (Data Fetching in Next.js)","text":""},{"location":"nextjs/data-fetching.html#data-fetching-in-nextjs","title":"\ud83d\udce1 Data Fetching in Next.js","text":"<p>Next.js supports various data-fetching strategies:</p> <ol> <li>Server-Side Rendering (SSR)</li> <li>Static Site Generation (SSG)</li> <li>Incremental Static Regeneration (ISR)</li> <li>Client-Side Fetching</li> </ol>"},{"location":"nextjs/data-fetching.html#example-server-side-rendering-ssr","title":"\ud83d\udccb Example: Server-Side Rendering (SSR)","text":"<pre><code>// app/page.tsx\nexport async function getServerSideProps() {\n  const data = await fetch(\"https://api.example.com/data\");\n  return { props: { data } };\n}\n</code></pre>"},{"location":"nextjs/deployment.html","title":"Deployment","text":""},{"location":"nextjs/deployment.html#6-deploymentmd-deploying-nextjs-apps","title":"\ud83d\udcdd 6. <code>deployment.md</code> (Deploying Next.js Apps)","text":""},{"location":"nextjs/deployment.html#deploying-nextjs-apps","title":"\ud83d\ude80 Deploying Next.js Apps","text":"<p>You can deploy Next.js apps to Vercel (recommended), Netlify, or other platforms.</p>"},{"location":"nextjs/deployment.html#deploy-to-vercel","title":"\u2705 Deploy to Vercel","text":"<pre><code>vercel deploy\n</code></pre>"},{"location":"nextjs/deployment.html#deploy-to-netlify","title":"\u2705 Deploy to Netlify","text":"<pre><code>netlify deploy\n</code></pre>"},{"location":"nextjs/deployment.html#deploy-with-docker","title":"\u2705 Deploy with Docker","text":"Create a Dockerfile<pre><code># Dockerfile\nFROM node:alpine\nWORKDIR /app\nCOPY . .\nRUN npm install\nRUN npm run build\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n</code></pre>"},{"location":"nextjs/folder-structure.html","title":"\ud83d\udcc2 Next.js Folder Structure","text":"<p>A standard Next.js project follows this folder structure:</p> <pre><code>my-next-app/\n\u251c\u2500\u2500 .next/              # Build output (generated after build)\n\u251c\u2500\u2500 app/                # App Router (Next.js 13+)\n\u2502   \u251c\u2500\u2500 layout.tsx      # Root layout\n\u2502   \u2514\u2500\u2500 page.tsx        # Root page\n\u251c\u2500\u2500 pages/              # Pages Router (Legacy)\n\u2502   \u2514\u2500\u2500 index.js        # Homepage\n\u251c\u2500\u2500 components/         # Reusable components\n\u251c\u2500\u2500 public/             # Static files (images, fonts, etc.)\n\u251c\u2500\u2500 styles/             # Global CSS files\n\u251c\u2500\u2500 next.config.js      # Next.js configuration\n\u251c\u2500\u2500 package.json        # Project dependencies\n\u2514\u2500\u2500 README.md           # Project documentation\n</code></pre> <p>\ud83d\udccc Key Folders</p> <ul> <li><code>app/</code>: New App Router for routes and layouts.</li> <li><code>pages/</code>: Legacy Pages Router for defining routes.</li> <li><code>public/</code>: Static assets like images, fonts, and files.</li> </ul>"},{"location":"nextjs/folder-structure.html#folder-structure-comparison","title":"\ud83d\udee0 Folder Structure Comparison","text":"Feature App Router Pages Router Routing File-based File-based Layouts Nested layouts No nested layouts Server Components Supported Not supported Data Fetching Methods SSG, SSR, ISR SSG, SSR API Routes <code>/app/api/</code> folder <code>/pages/api/</code> folder"},{"location":"nextjs/intro.html","title":"Next.js Documentation","text":"<p>Welcome to the Next.js Documentation!</p> <p>Next.js is a React framework that enables server-side rendering (SSR), static site generation (SSG), API routes, and more.</p>"},{"location":"nextjs/intro.html#key-features-of-nextjs","title":"\ud83d\ude80 Key Features of Next.js","text":"<ul> <li>File-based routing</li> <li>Server-side rendering (SSR)</li> <li>Static site generation (SSG)</li> <li>API routes</li> <li>Image optimization</li> <li>Built-in CSS and Sass support</li> <li>Fast performance and SEO-friendly</li> </ul>"},{"location":"nextjs/intro.html#what-youll-learn","title":"\ud83d\udcda What You'll Learn","text":"<ol> <li>Folder Structure</li> <li>Routing</li> <li>API Routes</li> <li>Data Fetching</li> <li>Deployment</li> <li>Configuration</li> </ol>"},{"location":"nextjs/intro.html#nextjs-mkdocs-file","title":"Next.js Mkdocs file","text":"<p>\ud83e\udde9 Update Your <code>mkdocs.yml</code></p> <p>Add the Next.js documentation to your MkDocs config:</p> <pre><code>nav:\n  - Home: index.md\n  - Next.js:\n      - Introduction: nextjs/index.md\n      - Folder Structure: nextjs/folder-structure.md\n      - Routing: nextjs/routing.md\n      - API Routes: nextjs/api-routes.md\n      - Data Fetching: nextjs/data-fetching.md\n      - Deployment: nextjs/deployment.md\n      - Configuration: nextjs/next-config.md\n</code></pre>"},{"location":"nextjs/next-config.html","title":"Configuration","text":""},{"location":"nextjs/next-config.html#7-next-configmd-nextconfigjs-configuration","title":"\ud83d\udcdd 7. <code>next-config.md</code> (next.config.js Configuration)","text":""},{"location":"nextjs/next-config.html#nextconfigjs-configuration","title":"\u2699\ufe0f next.config.js Configuration","text":"<p>The <code>next.config.js</code> file allows you to configure your Next.js app.</p>"},{"location":"nextjs/next-config.html#example-configuration","title":"\ud83d\udccb Example Configuration","text":"<pre><code>// next.config.js\nconst nextConfig = {\n  reactStrictMode: true,\n  images: {\n    domains: [\"example.com\"],\n  },\n};\n\nmodule.exports = nextConfig;\n</code></pre>"},{"location":"nextjs/routing.html","title":"Routing","text":""},{"location":"nextjs/routing.html#3-routingmd-routing-in-nextjs","title":"\ud83d\udcdd 3. <code>routing.md</code> (Routing in Next.js)","text":""},{"location":"nextjs/routing.html#routing-in-nextjs","title":"\ud83c\udf10 Routing in Next.js","text":"<p>Next.js uses file-based routing, where the file structure inside the <code>pages/</code> or <code>app/</code> folder determines the routes.</p>"},{"location":"nextjs/routing.html#app-router-new-in-nextjs-13","title":"\ud83d\uddc2 App Router (New in Next.js 13+)","text":"<p>In the App Router, routes are defined inside the <code>app/</code> folder.</p> <p>Example:</p> <pre><code>app/\n\u251c\u2500\u2500 page.tsx        # Route: /\n\u251c\u2500\u2500 about/\n\u2502   \u2514\u2500\u2500 page.tsx    # Route: /about\n\u2514\u2500\u2500 dashboard/\n    \u2514\u2500\u2500 page.tsx    # Route: /dashboard\npages/\n\u251c\u2500\u2500 index.js        # Route: /\n\u251c\u2500\u2500 about.js        # Route: /about\n\u2514\u2500\u2500 dashboard.js    # Route: /dashboard\n</code></pre>"},{"location":"theory/index.html","title":"Intro","text":""},{"location":"theory/index.html#built-in-routing","title":"Built-in Routing","text":"<p>Next.js provides built-in routing that makes it easy to create dynamic and complex websites with multiple pages.</p> <p>Here are some of the key features of Next.js routing.</p>"},{"location":"theory/index.html#file-based-routing","title":"File-based Routing","text":"<p>Let's say you have a website with the following pages:</p> <ul> <li>Home</li> <li>About</li> <li>Services</li> <li>Contact</li> </ul> <p>To create these pages in Next.js, you would create the following files in the pages directory:</p> <pre><code>pages/\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 about.js\n\u251c\u2500\u2500 services.js\n</code></pre> <p>The <code>index.js</code> file corresponds to the homepage of your website, and the other files correspond to the other pages. For example, the <code>about.js</code> file would contain the code for the About page, the <code>services.js</code> file would contain the code for the Services page, and so on.</p> pages/about.js<pre><code>function AboutPage() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;About Us&lt;/h1&gt;\n      &lt;p&gt;\n        We are a company that specializes in creating high-quality websites.\n      &lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\nexport default AboutPage;\n</code></pre> <p>In this example, we've created a simple About page component that contains a heading and some text. When a user visits the <code>/about</code> route on our website, Next.js will automatically render this component and serve it as an HTML response to the user's browser.</p>"},{"location":"theory/index.html#dynamic-routes","title":"Dynamic Routes","text":""},{"location":"theory/index.html#nested-routes","title":"Nested Routes","text":""},{"location":"theory/index.html#api-routes","title":"API Routes","text":"<p>Next.js also allows you to create API routes, which can be used to fetch data from your backend or third-party APIs.</p> <p>API routes are similar to regular routes, but instead of returning HTML, they return data in JSON format. This makes it easy to create powerful and exible APIs that can be used by your front end or other applications.</p> <p>Let's say you have a backend API that returns a list of products in JSON format. You want to create a front-end page that displays this list of products using Next.js. To do this, you can create an API route in</p> <p>Next.js that fetches the data from your backend API and returns it in JSON format.</p> <p>To create an API route in Next.js, you would create a file in the <code>pages/api</code> directory.</p> <pre><code>pages/\n\u2514\u2500\u2500 api\n\u2514\u2500\u2500 products.js\n</code></pre> pages/api/products.js<pre><code>export default async function handler(req, res) {\n  const response = await fetch(\"https://an-external-api.com/products\");\n  const products = await response.json();\n}\nres.status(200).json(products);\n</code></pre> <p>In this example, we're using the built-in fetch function to fetch the list of products from our backend API, and then return the list of products in JSON format using the <code>res.json()</code> method.</p> <p>Now, we can use this API route to fetch the list of products from our front-end page. Here's an example of what the front-end page might look like:</p> <pre><code>import { useState, useEffect } from \"react\";\nfunction ProductList() {\n  const [products, setProducts] = useState([]);\n  useEffect(async () =&gt; {\n    const response = await fetch(\"/api/products\");\n    const products = await response.json();\n    setProducts(products);\n  }, []);\n}\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;Product List&lt;/h1&gt;\n    &lt;ul&gt;\n      {products.map((product) =&gt; (\n        &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  &lt;/div&gt;\n);\nexport default ProductList;\n</code></pre> <p>In this example, we're using the built-in fetch function to fetch the list of products from our API route, and then using the <code>useState</code> and <code>useEffect</code> hooks to update the component state with the list of products.</p> <p>Now, when a user visits this page, Next.js will automatically fetch the list of products from the API route and display it on the page.</p>"},{"location":"theory/index.html#link-component","title":"Link Component","text":"<p>Next.js provides a <code>Link</code> component that makes it easy to create links between pages on your website. This component uses client-side rendering to navigate between pages, which can provide a faster and smoother user experience compared to traditional page reloads.</p> <pre><code>import Link from \"next/link\";\nfunction MyComponent() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;My Component&lt;/h1&gt;\n      &lt;Link href=\"/about\"&gt;\n        &lt;a&gt;About&lt;/a&gt;\n      &lt;/Link&gt;\n    &lt;/div&gt;\n  );\n}\nexport default MyComponent;\n</code></pre>"},{"location":"theory/index.html#reference","title":"Reference","text":"<ul> <li>Dynamic Trio by By Grace Huang, pg: 25</li> </ul>"}]}